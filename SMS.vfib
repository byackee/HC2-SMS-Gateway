{"name":"SMS","type":"virtual_device","properties":{"deviceIcon":249,"currentIcon":"249","log":"","logTemp":"","mainLoop":"","visible":"true","rows":[{"type":"button","elements":[{"id":1,"lua":true,"waitForResponse":false,"caption":"num-telephone","name":"Button11","empty":false,"msg":"local thismodule = fibaro:getSelfId();\nlocal deviceIp = fibaro:get(thismodule, 'IPAddress')\nlocal devicePort = fibaro:get(thismodule, 'TCPPort')\nlocal phone = fibaro:getGlobalValue(\"TelVince\")\nlocal sms = fibaro:getGlobalValue(\"sms\")\nlocal password = \"pass\"\n\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n-- Toolkit Framework, lua library extention for HC2, hope that it will be useful.\n-- This Framework is an addon for HC2 Toolkit application in a goal to aid the integration.\n-- Tested on Lua 5.1 with Fibaro HC2 3.572 beta\n--\n-- Version 1.0.2 [12-13-2013]\n--\n-- Use: Toolkit or Tk shortcut to access Toolkit namespace members.\n--\n-- Example:\n-- Toolkit:trace(\"value is %d\", 35); or Tk:trace(\"value is %d\", 35);\n-- Toolkit.assertArg(\"argument\", arg, \"string\"); or Tk.assertArg(\"argument\", arg, \"string\");\n--\n-- current release: http://krikroff77.github.io/Fibaro-HC2-Toolkit-Framework/\n-- latest release: https://github.com/Krikroff77/Fibaro-HC2-Toolkit-Framework/releases/latest\n--\n-- Memory is preserved: The code is loaded only the first time in a virtual device \n-- main loop and reloaded only if application pool restarded.\n--\n-- Copyright (C) 2013 Jean-Christophe Vermandé\n-- \n-- This program is free software: you can redistribute it and/or modify\n-- it under the terms of the GNU General Public License as published by\n-- the Free Software Foundation, either version 3 of the License, or\n-- at your option) any later version.\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\nif not Toolkit then Toolkit = { \n  __header = \"Toolkit\",\n  __version = \"1.0.2\",\n  __luaBase = \"5.1.0\", \n  __copyright = \"Jean-Christophe Vermandé\",\n  __licence = [[\n\tCopyright (C) 2013 Jean-Christophe Vermandé\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses></http:>.\n  ]],\n  __frameworkHeader = (function(self)\n    self:traceEx(\"green\", \"-------------------------------------------------------------------------\");\n    self:traceEx(\"green\", \"-- HC2 Toolkit Framework version %s\", self.__version);\n    self:traceEx(\"green\", \"-- Current interpreter version is %s\", self.getInterpreterVersion());\n    self:traceEx(\"green\", \"-- Total memory in use by Lua: %.2f Kbytes\", self.getCurrentMemoryUsed());\n    self:traceEx(\"green\", \"-------------------------------------------------------------------------\");\n  end),\n  -- chars\n  chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n  -- hex\n  hex = \"0123456789abcdef\",\n  -- now(), now(\"*t\", 906000490)\n  -- system date shortcut\n  now = os.date,\n  -- toUnixTimestamp(t)\n  -- t (table)\t\t- {year=2013, month=12, day=20, hour=12, min=00, sec=00}\n  -- return Unix timestamp\n  toUnixTimestamp = (function(t) return os.time(t) end),\n  -- fromUnixTimestamp(ts)\n  -- ts (string/integer)\t- the timestamp\n  -- Example : fromUnixTimestamp(1297694343) -> 02/14/11 15:39:03\n  fromUnixTimestamp = (function(s) return os.date(\"%c\", ts) end),\n  -- currentTime()\n  -- return current time\n  currentTime = (function() return tonumber(os.date(\"%H%M%S\")) end),\n  -- comparableTime(hour, min, sec)\n  -- hour (string/integer)\n  -- min (string/integer)\n  -- sec (string/integer)\n  comparableTime = (function(hour, min) return tonumber(string.format(\"%02d%02d%02d\", hour, min, sec)) end),\n  -- isTraceEnabled\n  -- (boolean)\tget or set to enable or disable trace\n  isTraceEnabled = true,\n  -- isAutostartTrigger()\n  isAutostartTrigger = (function() local t = fibaro:getSourceTrigger();return (t[\"type\"]==\"autostart\") end),\n  -- isOtherTrigger()\n  isOtherTrigger = (function() local t = fibaro:getSourceTrigger();return (t[\"type\"]==\"other\") end),\n  -- raiseError(message, level)\n  -- message (string)\t- message\n  -- level (integer)\t- level\n  raiseError = (function(message, level) error(message, level); end),\n  -- colorSetToRgbwTable(colorSet)\n  -- colorSet (string) - colorSet string\n  -- Example: local r, g, b, w = colorSetToRgbwTable(fibaro:getValue(354, \"lastColorSet\"));\n  colorSetToRgbw = (function(self, colorSet)\n    self.assertArg(\"colorSet\", colorSet, \"string\");\n    local t, i = {}, 1;\n    for v in string.gmatch(colorSet,\"(%d+)\") do t[i] = v; i = i + 1; end\n    return t[1], t[2], t[3], t[4];\n  end),\n  -- isValidJson(data, raise)\n  -- data (string)\t- data\n  -- raise (boolean)- true if must raise error\n  -- check if json data is valid\n  isValidJson = (function(self, data, raise)\n    self.assertArg(\"data\", data, \"string\");\n    self.assertArg(\"raise\", raise, \"boolean\");\n    if (string.len(data)>0) then\n      if (pcall(function () return json.decode(data) end)) then\n        return true;\n      else\n        if (raise) then self.raiseError(\"invalid json\", 2) end;\n      end\n    end\n    return false;\n  end),\n  -- assert_arg(name, value, typeOf)\n  -- (string)\tname: name of argument\n  -- (various)\tvalue: value to check\n  -- (type)\t\ttypeOf: type used to check argument\n  assertArg = (function(name, value, typeOf)\n    if type(value) ~= typeOf then\n      Tk.raiseError(\"argument \"..name..\" must be \"..typeOf, 2);\n    end\n  end),\n  -- trace(value, args...)\n  -- (string)\tvalue: value to trace (can be a string template if args)\n  -- (various)\targs: data used with template (in value parameter)\n  trace = (function(self, value, ...)\n    if (self.isTraceEnabled) then\n      if (value~=nil) then        \n        return fibaro:debug(string.format(value, ...));\n      end\n    end\n  end),\n  -- traceEx(value, args...)\n  -- (string)\tcolor: color use to display the message (red, green, yellow)\n  -- (string)\tvalue: value to trace (can be a string template if args)\n  -- (various)\targs: data used with template (in value parameter)\n  traceEx = (function(self, color, value, ...)\n    self:trace(string.format('<%s style=\"color:%s;\">%s</%s>', \"span\", color, string.format(value, ...), \"span\"));\n  end),\n  -- getInterpreterVersion()\n  -- return current lua interpreter version\n  getInterpreterVersion = (function()\n    return _VERSION;\n  end),\n  -- getCurrentMemoryUsed()\n  -- return total current memory in use by lua interpreter\n  getCurrentMemoryUsed = (function()\n    return collectgarbage(\"count\");\n  end),\n  -- trim(value)\n  -- (string)\tvalue: the string to trim\n  trim = (function(s)\n    Tk.assertArg(\"value\", s, \"string\");\n    return (string.gsub(s, \"^%s*(.-)%s*$\", \"%1\"));\n  end),\n  -- filterByPredicate(table, predicate)\n  -- table (table)\t\t- table to filter\n  -- predicate (function)\t- function for predicate\n  -- Description: filter a table using a predicate\n  -- Usage:\n  -- local t = {1,2,3,4,5};\n  -- local out, n = filterByPredicate(t,function(v) return v.item == true end);\n  -- return out -> {2,4}, n -> 2;\n  filterByPredicate = (function(table, predicate)\n    Tk.assertArg(\"table\", table, \"table\");\n    Tk.assertArg(\"predicate\", predicate, \"function\");\n    local n, out = 1, {};\n    for i = 1,#table do\n      local v = table[i];\n      if (v~=nil) then\n        if predicate(v) then\n            out[n] = v;\n            n = n + 1;    \n        end\n      end\n    end  \n    return out, #out;\n  end)\n};Toolkit:__frameworkHeader();Tk=Toolkit;\nend;\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n-- Toolkit.Debug library extention\n-- Provide help to trace and debug lua code on Fibaro HC2\n-- Tested on Lua 5.1 with HC2 3.572 beta\n--\n-- Copyright 2013 Jean-christophe Vermandé\n--\n-- Version 1.0.1 [12-12-2013]\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\nif not Toolkit.Debug then Toolkit.Debug = { \n  __header = \"Toolkit.Debug\",\n  __version = \"1.0.1\",\n  -- The os.clock function returns the number of seconds of CPU time for the program.\n  __clocks = {[\"fragment\"]=os.clock(), [\"all\"]=os.clock()},\n  -- benchmarkPoint(name)\n  -- (string)\tname: name of benchmark point\n  benchmarkPoint = (function(self, name)\n    __clocks[name] = os.clock();\n  end),\n  -- benchmark(message, template, name, reset)\n  -- (string) \tmessage: value to display, used by template\n  -- (string) \ttemplate: template used to diqplay message\n  -- (string) \tname: name of benchmark point\n  -- (boolean) \treset: true to force reset clock\n  benchmark = (function(self, message, template, name, reset)\n    Toolkit.assertArg(\"message\", message, \"string\");\n    Toolkit.assertArg(\"template\", message, \"string\");\n    if (reset~=nil) then Toolkit.assertArg(\"reset\", reset, type(true)); end\n    Toolkit:traceEx(\"yellow\", \"Benchmark [\"..message..\"]: \"..\n      string.format(template, os.clock() - self.__clocks[name]));\n    if (reset==true) then self.__clocks[name] = os.clock(); end\n  end)\n};\nToolkit:traceEx(\"red\", Toolkit.Debug.__header..\" loaded in memory...\");\n-- benchmark code\nif (Toolkit.Debug) then Toolkit.Debug:benchmark(Toolkit.Debug.__header..\" lib\", \"elapsed time: %.3f cpu secs\\n\", \"fragment\", true); end ;\nend;\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\n-- Toolkit.Net library extention\n-- Toolkit.Net.HttpRequest provide http request with advanced functions\n-- Tested on Lua 5.1 with HC2 3.572 beta\n--\n-- Copyright 2013 Jean-christophe Vermandé\n-- Thanks to rafal.m for the decodeChunks function used when reponse body is \"chunked\"\n-- http://en.wikipedia.org/wiki/Chunked_transfer_encoding\n--\n-- Version 1.0.3 [12-13-2013]\n-------------------------------------------------------------------------------------------\n-------------------------------------------------------------------------------------------\nif not Toolkit then error(\"You must add Toolkit\", 2) end\nif not Toolkit.Net then Toolkit.Net = {\n  -- private properties\n  __header = \"Toolkit.Net\",\n  __version = \"1.0.3\",\n  __cr = string.char(13),\n  __lf = string.char(10),\n  __crLf = string.char(13, 10),\n  __host = nil,\n  __port = nil,\n  -- private methods\n  __trace = (function(v, ...)\n    if (Toolkit.Net.isTraceEnabled) then Toolkit:trace(v, ...) end\n  end),\n  __writeHeader = (function(socket, data)\n    assert(tostring(data) or data==nil or data==\"\", \"Invalid header found: \"..data);\n    local head = tostring(data);\n    socket:write(head..Toolkit.Net.__crLf);\n    Toolkit.Net.__trace(\"%s.%s::request > Add header [%s]\", \n      Toolkit.Net.__header, Toolkit.Net.__Http.__header, head);\n  end),\n  __decodeChunks = (function(a)\n    resp = \"\";\n    line = \"0\";\n    lenline = 0;\n    len = string.len(a);\n    i = 1;\n    while i<=len do\n      c = string.sub(a, i, i);\n      if (lenline==0) then\n        if (c==Toolkit.Net.__lf) then\n          lenline = tonumber(line, 16);\n          if (lenline==null) then\n            lenline = 0;\n          end\n          line = 0;\n        elseif (c==Toolkit.Net.__cr) then\n          lenline = 0;\n        else\n          line = line .. c;\n        end\n      else\n        resp = resp .. c;\n        lenline = lenline - 1;\n      end\n      i = i + 1;\n    end\n    return resp;\n  end),\n  __readHeader = (function(data)\n    if data == nil then\n      error(\"Couldn't find header\");\n    end\n    local buffer = \"\";\n    local headers = {};\n    local i, len = 1, string.len(data);\n    while i<=len do\n      local a = data:sub(i,i) or \"\";\n      local b = data:sub(i+1,i+1) or \"\";\n      if (a..b == Toolkit.Net.__crLf) then\n        i = i + 1;\n        table.insert(headers, buffer);\n        buffer = \"\";\n      else\n        buffer = buffer..a;     \n      end\n      i = i + 1;\n    end\n    return headers;\n  end),\n  __readSocket = (function(socket)\n    local err, len = 0, 1;\n    local buffer, data = \"\", \"\";\n    while (err==0 and len>0) do\n      data, err = socket:read();\n      len = string.len(data);\n      buffer = buffer..data;\n    end\n    return buffer, err;\n  end),\n  __Http = {\n    __header = \"HttpRequest\",\n    __version = \"1.0.3\",    \n    __tcpSocket = nil,\n    __timeout = 250,\n    __waitBeforeReadMs = 25,\n    __isConnected = false,\n    __isChunked = false,\n    __url = nil,\n    __method = \"GET\",  \n    __headers = {},\n    __body = nil,\n    __authorization = nil,\n    -- Toolkit.Net.HttpRequest:setBasicAuthentication(username, password)\n    -- Sets basic credentials for all requests.\n    -- username (string) – credentials username\n    -- password (string) – credentials password\n    setBasicAuthentication = (function(self, username, password)\n      Toolkit.assertArg(\"username\", username, \"string\");\n      Toolkit.assertArg(\"password\", password, \"string\");\n      --see: http://en.wikipedia.org/wiki/Basic_access_authentication\n      self.__authorization = Toolkit.Crypto.Base64:encode(tostring(username..\":\"..password));\n    end),\n    -- Toolkit.Net.HttpRequest:setBasicAuthenticationEncoded(base64String)\n    -- Sets basic credentials already encoded. Avoid direct exposure for information.\n    -- base64String (string)\t- username and password encoded with base64\n    setBasicAuthenticationEncoded = (function(self, base64String)\n      Toolkit.assertArg(\"base64String\", base64String, \"string\");\n      self.__authorization = base64String;\n    end),\n    -- Toolkit.Net.HttpRequest:setWaitBeforeReadMs(ms)\n    -- Sets ms\n    -- ms (integer) – timeout value in milliseconds\n    setWaitBeforeReadMs = (function(self, ms)\n      Toolkit.assertArg(\"ms\", ms, \"integer\");\n      self.__waitBeforeReadMs = ms;\n      Toolkit.Net.__trace(\"%s.%s::setWaitBeforeReadMs > set to %d ms\", \n        Toolkit.Net.__header, Toolkit.Net.__Http.__header, ms);\n    end),\n    -- Toolkit.Net.HttpRequest.getWaitBeforeReadMs()\n    -- Returns the value in milliseconds\n    getWaitBeforeReadMs = (function(self)\n      return self.__waitBeforeReadMs;\n    end),\n    -- Toolkit.Net.HttpRequest.setReadTimeout(ms)\n    -- Sets timeout\n    -- ms (integer) – timeout value in milliseconds\n  \tsetReadTimeout = (function(self, ms)\n      Toolkit.assertArg(\"ms\", ms, \"number\");\n      self.__timeout = ms;\n      Toolkit.Net.__trace(\"%s.%s::setReadTimeout > Timeout set to %d ms\", \n        Toolkit.Net.__header, Toolkit.Net.__Http.__header, ms);\n    end),\n    -- Toolkit.Net.HttpRequest.getReadTimeout()\n    -- Returns the timeout value in milliseconds\n    getReadTimeout = (function(self)\n      return self.__timeout;\n    end),\n    -- Toolkit.Net.HttpRequest:disconnect()\n    -- Disconnect the socket used by httpRequest\n    disconnect = (function(self)\n      self.__tcpSocket:disconnect();\n      self.__isConnected = false;\n      Toolkit.Net.__trace(\"%s.%s::disconnect > Connected: %s\", \n        Toolkit.Net.__header, Toolkit.Net.__Http.__header, tostring(self.__isConnected));\n    end),\n    -- Toolkit.Net.HttpRequest:request(method, uri, headers, body)\n    -- method (string)\t- method used for the request\n    -- uri (string)\t\t- uri used for the request\n    -- headers (table)\t- headers used for the request (option)\n    -- body (string)\t- data sent with the request (option)\n    request = (function(self, method, uri, headers, body)\n      -- validation\n      Toolkit.assertArg(\"method\", method, \"string\");\n      assert(method==\"GET\" or method==\"POST\" or method==\"PUT\" or method==\"DELETE\");\n      assert(uri~=nil or uri==\"\");\n      self.__isChunked = false;\n      self.__tcpSocket:setReadTimeout(self.__timeout);\n      self.__url = uri;\n      self.__method = method;\n      self.__headers = headers or {};\n      self.__body = body or nil;\n      local p = \"\";\n      if (Toolkit.Net.__port~=nil) then\n        p = \":\"..tostring(Toolkit.Net.__port);\n      end\n          \n      local r = self.__method..\" \".. self.__url ..\" HTTP/1.1\";\n      Toolkit.Net.__trace(\"%s.%s::request > %s with method %s\", \n          Toolkit.Net.__header, Toolkit.Net.__Http.__header, self.__url, self.__method);\n\n      local h = \"Host: \"..Toolkit.Net.__host .. p;\n      -- write to socket headers method a host!\n      Toolkit.Net.__writeHeader(self.__tcpSocket, r);\n      Toolkit.Net.__writeHeader(self.__tcpSocket, h);\n      -- add headers if needed\n      for i = 1, #self.__headers do\n        Toolkit.Net.__writeHeader(self.__tcpSocket, self.__headers[i]);\n      end\n      if (self.__authorization~=nil) then\n        Toolkit.Net.__writeHeader(self.__tcpSocket, \"Authorization: Basic \"..self.__authorization);\n      end\n      -- add data in body if needed\n      if (self.__body~=nil) then\n        Toolkit.Net.__writeHeader(self.__tcpSocket, \"Content-Length: \"..string.len(self.__body));\n        Toolkit.Net.__trace(\"%s.%s::request > Body length is %d\", \n          Toolkit.Net.__header, Toolkit.Net.__Http.__header, string.len(self.__body));\n      end\n      self.__tcpSocket:write(Toolkit.Net.__crLf..Toolkit.Net.__crLf);\n      -- write body\n      if (self.__body~=nil) then\n        self.__tcpSocket:write(self.__body);\n      end\n      -- sleep to help process\n      fibaro:sleep(self.__waitBeforeReadMs);\n      -- wait socket reponse\n      local result, err = Toolkit.Net.__readSocket(self.__tcpSocket);\n      Toolkit.Net.__trace(\"%s.%s::receive > Length of result: %d\", \n          Toolkit.Net.__header, Toolkit.Net.__Http.__header, string.len(result));\n      -- parse data\n      local response, status;\n      if (string.len(result)>0) then\n        local _flag = string.find(result, Toolkit.Net.__crLf..Toolkit.Net.__crLf);\n        local _rawHeader = string.sub(result, 1, _flag + 2);\n        if (string.len(_rawHeader)) then\n          status = string.sub(_rawHeader, 10, 13);\n          Toolkit.Net.__trace(\"%s.%s::receive > Status %s\", Toolkit.Net.__header, \n            Toolkit.Net.__Http.__header, status);\n          Toolkit.Net.__trace(\"%s.%s::receive > Length of headers reponse %d\", Toolkit.Net.__header, \n            Toolkit.Net.__Http.__header, string.len(_rawHeader));\n          __headers = Toolkit.Net.__readHeader(_rawHeader);\n          for k, v in pairs(__headers) do\n            --Toolkit.Net.__trace(\"raw #\"..k..\":\"..v)\n            if (string.find(string.lower( v or \"\"), \"chunked\")) then\n              self.__isChunked = true;\n              Toolkit.Net.__trace(\"%s.%s::receive > Transfer-Encoding: chunked\", \n          \t\tToolkit.Net.__header, Toolkit.Net.__Http.__header, string.len(result));\n            end\n          end\n        end\n        local _rBody = string.sub(result, _flag + 4);\n        --Toolkit.Net.__trace(\"Length of body reponse: \" .. string.len(_rBody));\n        if (self.__isChunked) then\n          response = Toolkit.Net.__decodeChunks(_rBody);\n          err = 0;\n        else\n          response = _rBody;\n          err = 0;\n        end\n      end\n      -- return budy response\n      return response, status, err;\n    end),\n    -- Toolkit.Net.HttpRequest.version()\n    -- Return the version\n    version = (function()\n      return Toolkit.Net.__Http.__version;\n    end),\n    -- Toolkit.Net.HttpRequest:dispose()\n    -- Try to free memory and resources \n    dispose = (function(self)      \n      if (self.__isConnected) then\n      \tself.__tcpSocket:disconnect();\n      end\n      self.__tcpSocket = nil;\n      self.__url = nil;\n      self.__headers = nil;\n      self.__body = nil;\n      self.__method = nil;\n      if pcall(function () assert(self.__tcpSocket~=Net.FTcpSocket) end) then\n        Toolkit.Net.__trace(\"%s.%s::dispose > Successfully disposed\", \n          Toolkit.Net.__header, Toolkit.Net.__Http.__header);\n      end\n      -- make sure all free-able memory is freed\n      collectgarbage(\"collect\");\n      Toolkit.Net.__trace(\"%s.%s::dispose > Total memory in use by Lua: %.2f Kbytes\", \n        Toolkit.Net.__header, Toolkit.Net.__Http.__header, collectgarbage(\"count\"));\n    end)\n  },\n  -- Toolkit.Net.isTraceEnabled\n  -- true for activate trace in HC2 debug window\n  isTraceEnabled = false,\n  -- Toolkit.Net.HttpRequest(host, port)\n  -- Give object instance for make http request\n  -- host (string)\t- host\n  -- port (intager)\t- port\n  -- Return HttpRequest object\n  HttpRequest = (function(host, port)\n    assert(host~=Toolkit.Net, \"Cannot call HttpRequest like that!\");\n    assert(host~=nil, \"host invalid input\");\n    assert(port==nil or tonumber(port), \"port invalid input\");\n    -- make sure all free-able memory is freed to help process\n    collectgarbage(\"collect\");\n    Toolkit.Net.__host = host;\n    Toolkit.Net.__port = port;\n    local _c = Toolkit.Net.__Http;\n    _c.__tcpSocket = Net.FTcpSocket(host, port);\n    _c.__isConnected = true;\n    Toolkit.Net.__trace(\"%s.%s > Total memory in use by Lua: %.2f Kbytes\", \n          Toolkit.Net.__header, Toolkit.Net.__Http.__header, collectgarbage(\"count\"));\n    Toolkit.Net.__trace(\"%s.%s > Create Session on port: %d, host: %s\", \n          Toolkit.Net.__header, Toolkit.Net.__Http.__header, port, host);\n    return _c;\n  end),\n  -- Toolkit.Net.version()\n  version = (function()\n    return Toolkit.Net.__version;\n  end)\n};\n\nToolkit:traceEx(\"red\", Toolkit.Net.__header..\" loaded in memory...\");\n-- benchmark code\nif (Toolkit.Debug) then Toolkit.Debug:benchmark(Toolkit.Net.__header..\" lib\", \"elapsed time: %.3f cpu secs\\n\", \"fragment\", true); end;\nend;\n----------------------------------------------------------------------------\n-- URL-encode a string (see RFC 2396)\n----------------------------------------------------------------------------\nfunction urlencode(str)\n  if (str) then\n    str = string.gsub (str, \"\\n\", \"\\r\\n\")\n    str = string.gsub (str, \"([^%w ])\", function (c) return string.format (\"%%%02X\", string.byte(c)) end)\n    str = string.gsub (str, \" \", \"+\")\n  end\n  return str\nend\n-------------------------------------------------------------------------------------------\n-- Main process\n-------------------------------------------------------------------------------------------\nfunction SendSMS(number, message)\n  local uri = \"/sendsms\";\n  local params = \"?phone=\" .. number .. \"&text=\" .. urlencode(tostring(message or \"empty\")) .. \"&password=\" .. password;\n  Tk.Net.isTraceEnabled = false;\n  local HttpClient = Tk.Net.HttpRequest(deviceIp, devicePort);\n  HttpClient:setReadTimeout(500);\n  local response, status, errorCode = HttpClient:request(\"GET\", \n    uri..params, {\n      \"User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:25.0) Gecko/20100101 Firefox/25.0\",\n      \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9\"\n    });\n  HttpClient:disconnect();\n  HttpClient:dispose();\n  HttpClient = nil;\n  fibaro:debug(response)\n\nend\n\n-- numéro de tel, message...\nSendSMS(phone, sms);\n","buttonIcon":249,"favourite":false,"main":true}]}]},"actions":{"pressButton":1,"setSlider":2,"setProperty":2}}